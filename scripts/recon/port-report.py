#!/bin/python3

import sys
import socket
from datetime import datetime
import argparse
from threading import Thread
import time
import random

# Define command-line arguments
parser = argparse.ArgumentParser()
parser.add_argument("ip", help="IP address of the target host")
parser.add_argument("-p", "--ports", help="Port range to scan (default: 1-1000)")
args = parser.parse_args()

# Define target IP and port range
target = args.ip
if args.ports:
    start_port, end_port = map(int, args.ports.split("-"))
else:
    start_port, end_port = 1, 1000

# Add a banner
print("-" * 50)
print("[*]   Scanning Target...")
print("[*]   Time Started: "+str(datetime.now()))
print("[*]   Target IP: {}".format(target))
print("[*]   Port range: {}-{}".format(start_port, end_port))
print("-" * 50)

# Create output file
file = open("scan_results.txt", "w")
file.write("Scan Results for: " + target + "\n")
file.write("Time Started: " + str(datetime.now()) + "\n")

# Randomize the order in which ports are scanned
ports = random.sample(range(start_port, end_port+1), end_port-start_port+1)

# Check for open ports on a router like dns
def scan(port):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(1)
        result = s.connect_ex((target, port))
                if result == 0:
            print(f"Port {port} is open")
            file.write(f"Port {port} is open\n")
        s.close()
    except Exception as e:
        print(f"Error: {e}")

# Use threading to speed up the scanning process
threads = []
for port in ports:
    t = Thread(target=scan, args=(port,))
    threads.append(t)
    t.start()
    time.sleep(0.1) # add delay between each connection attempt

# Wait for all threads to complete
for t in threads:
    t.join()

# Add footer to output file
file.write("\nTime Completed: " + str(datetime.now()))
file.close()
